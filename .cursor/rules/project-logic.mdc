---
description: Core development patterns, workflows, and architectural guidelines for RIXS Preparation Toolbox
alwaysApply: false
---

# RIXS Preparation Toolbox - Project Logic Guide

## Core Application Logic Flow

### 1. Application Initialization Sequence

```mermaid
sequenceDiagram
    participant User
    participant main.py
    participant MainWindow
    participant InitWindow
    participant TabRegistry
    participant Tabs

    User->>main.py: Launch application
    main.py->>MainWindow: Create instance
    MainWindow->>InitWindow: Show initialization
    InitWindow->>User: Request lattice parameters
    User->>InitWindow: Provide parameters/CIF
    InitWindow->>MainWindow: Parameters validated
    MainWindow->>TabRegistry: Load tab definitions
    TabRegistry->>MainWindow: Return tab configs
    MainWindow->>Tabs: Create and initialize tabs
    Tabs->>MainWindow: Tabs ready
    MainWindow->>User: Show main interface
```

### 2. Parameter Distribution Logic

**Global State Management Pattern**:
```python
# In MainWindow
def set_global_parameters(self, params):
    """Distribute parameters to all tabs"""
    self.global_params = params
    for i in range(self.tab_widget.count()):
        tab = self.tab_widget.widget(i)
        if hasattr(tab, 'set_parameters'):
            tab.set_parameters(params)

# In each Tab
def set_parameters(self, params: dict):
    """Initialize backend with global parameters"""
    if hasattr(self, 'calculator'):
        self.calculator.initialize(params)
```

### 3. Coordinate System Logic

**Three-Layer Transformation Architecture**:

```python
# Initialization Chain
lattice = Lattice(a, b, c, alpha, beta, gamma)
sample = Sample(lattice, roll, pitch, yaw)
lab = Lab(sample, theta, phi, chi)

# Transformation Usage
vector_lab = lab.transform_to_lab(vector_lattice)
hkl_reciprocal = lab.calculate_hkl(tth, theta, phi, chi)
```

**Key Coordinate Frame Logic**:
- **Lattice Frame**: Crystal structure reference (a, b, c axes)
- **Sample Frame**: Sample surface reference (Z normal to surface)
- **Lab Frame**: Beam reference (Z along incident beam)

## Development Patterns

### 1. Module Creation Pattern

#### Standard Pattern (Coordinate System Based)

**Backend Module Template** (`packages/module_name/interface.py`):
```python
from packages.classes.lab import Lab

class ModuleName:
    """Backend calculator for module functionality."""
    
    def __init__(self):
        """Initialize calculator."""
        self._initialized = False
        self.lab = Lab()
        self.results = {}
    
    def initialize(self, params: dict):
        """Initialize with global lattice parameters."""
        try:
            # Extract required parameters
            a, b, c = params['a'], params['b'], params['c']
            alpha, beta, gamma = params['alpha'], params['beta'], params['gamma']
            
            # Optional sample orientation
            roll = params.get('roll', 0.0)
            pitch = params.get('pitch', 0.0) 
            yaw = params.get('yaw', 0.0)
            
            # Initialize lab object
            self.lab.initialize(a, b, c, alpha, beta, gamma, 
                              roll, pitch, yaw, 0.0, 0.0, 0.0)
            self._initialized = True
            
        except KeyError as e:
            raise ValueError(f"Missing required parameter: {e}")
    
    def calculate_something(self, input_params):
        """Perform module calculations."""
        if not self._initialized:
            raise RuntimeError("Module not initialized")
        
        # Use self.lab for coordinate transformations
        # Return results as dictionary
        return self.results
```

**Frontend Tab Template** (`packages/gui/tabs/modulenamertab.py`):
```python
from PyQt5.QtWidgets import QLabel, QPushButton, QLineEdit
from packages.gui.tabs.tab_interface import TabInterface
from packages.module_name.interface import ModuleName

class ModuleNameTab(TabInterface):
    """Frontend tab for ModuleName functionality."""
    
    def __init__(self, main_window=None):
        """Initialize tab with backend instance."""
        self.calculator = ModuleName()
        super().__init__(main_window)
    
    def init_ui(self):
        """Create UI components."""
        # Input widgets
        self.input_widget = QLineEdit()
        self.layout.addWidget(QLabel("Input:"), 0, 0)
        self.layout.addWidget(self.input_widget, 0, 1)
        
        # Action button
        self.calculate_btn = QPushButton("Calculate")
        self.calculate_btn.clicked.connect(self.on_calculate)
        self.layout.addWidget(self.calculate_btn, 1, 0, 1, 2)
        
        # Results display
        self.results_label = QLabel("Results will appear here")
        self.layout.addWidget(self.results_label, 2, 0, 1, 2)
    
    def set_parameters(self, params: dict):
        """Receive global parameters from MainWindow."""
        try:
            self.calculator.initialize(params)
        except Exception as e:
            self.results_label.setText(f"Initialization error: {e}")
    
    def on_calculate(self):
        """Handle calculate button click."""
        try:
            input_value = float(self.input_widget.text())
            results = self.calculator.calculate_something(input_value)
            self.results_label.setText(f"Result: {results}")
        except Exception as e:
            self.results_label.setText(f"Calculation error: {e}")
```

#### Specialized Pattern (Independent Initialization)

For modules requiring specific file formats or parameters not part of the global lattice configuration:

**Backend Module Template** (`packages/module_name/interface.py`):
```python
class SpecializedCalculator:
    """Backend calculator with independent initialization."""
    
    def __init__(self):
        """Initialize calculator."""
        self._initialized = False
        self.results = {}
        # Module-specific properties
        self._file_path = None
        self._energy = None
    
    @property
    def is_initialized(self):
        return self._initialized
    
    def initialize(self, file_path: str, energy: float):
        """Initialize with module-specific parameters."""
        try:
            # Validate inputs
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist")
            
            self._file_path = file_path
            self._energy = energy
            
            # Initialize external library/calculator
            self.calculator = ExternalLibrary(self._file_path)
            self.calculator.setup(energy=self._energy)
            
            self._initialized = True
            
        except Exception as e:
            raise ValueError(f"Initialization failed: {e}")
    
    def calculate_something(self, input_params):
        """Perform specialized calculations."""
        if not self._initialized:
            raise RuntimeError("Calculator not initialized")
        
        return self.calculator.compute(input_params)
```

**Frontend Tab Template** (`packages/gui/tabs/specializedtab.py`):
```python
from PyQt5.QtWidgets import QGroupBox, QFileDialog, QDoubleSpinBox
from packages.gui.tabs.tab_interface import TabInterface
from packages.module_name.interface import SpecializedCalculator

class SpecializedTab(TabInterface):
    """Frontend tab for specialized functionality."""
    
    def __init__(self, main_window=None):
        """Initialize tab with backend instance."""
        self.calculator = SpecializedCalculator()
        self._calculator_initialized = False
        super().__init__(main_window)
    
    def init_ui(self):
        """Create UI components with initialization controls."""
        # Configuration section
        config_group = QGroupBox("Configuration")
        config_layout = QFormLayout(config_group)
        
        # File selection
        file_layout = QHBoxLayout()
        self.file_path_display = QLineEdit()
        self.file_path_display.setReadOnly(True)
        file_layout.addWidget(self.file_path_display)
        
        self.browse_btn = QPushButton("Browse...")
        self.browse_btn.clicked.connect(self.browse_file)
        file_layout.addWidget(self.browse_btn)
        config_layout.addRow("Input File:", file_layout)
        
        # Parameter input
        self.param_input = QDoubleSpinBox()
        self.param_input.setRange(1.0, 100000.0)
        self.param_input.setValue(10000.0)
        config_layout.addRow("Parameter:", self.param_input)
        
        # Initialize button
        self.init_btn = QPushButton("Initialize Calculator")
        self.init_btn.clicked.connect(self.initialize_calculator)
        config_layout.addRow("", self.init_btn)
        
        # Status display
        self.status_label = QLabel("Status: Please configure and initialize")
        config_layout.addRow("", self.status_label)
        
        self.layout.addWidget(config_group, 0, 0)
        
        # Calculation controls (disabled until initialized)
        self.calc_btn = QPushButton("Calculate")
        self.calc_btn.clicked.connect(self.calculate)
        self.calc_btn.setEnabled(False)
        self.layout.addWidget(self.calc_btn, 1, 0)
    
    def set_parameters(self, params: dict):
        """Handle global parameters (may not be applicable)."""
        # For specialized modules, global parameters might not be used
        # or only used for visualization components
        pass
    
    def browse_file(self):
        """Browse for input file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select Input File", "", "Input Files (*.ext);;All Files (*)"
        )
        if file_path:
            self.file_path_display.setText(file_path)
    
    def initialize_calculator(self):
        """Initialize the specialized calculator."""
        try:
            file_path = self.file_path_display.text()
            param_value = self.param_input.value()
            
            if not file_path:
                QMessageBox.warning(self, "Warning", "Please select an input file!")
                return
            
            self.calculator.initialize(file_path, param_value)
            self._calculator_initialized = True
            
            self.status_label.setText("Status: Calculator initialized successfully")
            self.calc_btn.setEnabled(True)
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to initialize: {str(e)}")
            self.status_label.setText(f"Status: Initialization failed")
    
    def calculate(self):
        """Perform calculations."""
        if not self._calculator_initialized:
            QMessageBox.warning(self, "Warning", "Please initialize first!")
            return
        
        try:
            results = self.calculator.calculate_something(input_params)
            self.display_results(results)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")
```

**Key Differences for Specialized Modules**:
- Independent initialization not tied to global parameters
- UI includes configuration controls for module-specific setup
- Validation of external dependencies (files, libraries)
- Separate enable/disable state management for calculation controls
- Error handling for both initialization and calculation phases

### 2. Tab Registry Integration

**Adding New Tab to Registry** ([tab_registry.json](mdc:config/tab_registry.json)):
```json
{
    "id": "module_name",
    "name": "Module Display Name",
    "description": "Brief description of functionality",
    "module_package": "module_name",
    "tab_class": "ModuleNameTab", 
    "icon": "icons/module.png",
    "enabled": true,
    "order": 4
}
```

### 3. Error Handling Patterns

**Initialization Error Handling**:
```python
def set_parameters(self, params: dict):
    """Safe parameter initialization."""
    try:
        self.calculator.initialize(params)
        self.status_label.setText("Ready")
        self.enable_controls(True)
    except (ValueError, KeyError) as e:
        self.status_label.setText(f"Configuration error: {e}")
        self.enable_controls(False)
    except Exception as e:
        self.status_label.setText(f"Unexpected error: {e}")
        self.enable_controls(False)
```

**Calculation Error Handling**:
```python
def perform_calculation(self):
    """Safe calculation execution."""
    if not self.calculator._initialized:
        self.show_error("Module not initialized")
        return
    
    try:
        inputs = self.get_user_inputs()
        self.validate_inputs(inputs)
        results = self.calculator.calculate(inputs)
        self.display_results(results)
    except ValueError as e:
        self.show_error(f"Input error: {e}")
    except Exception as e:
        self.show_error(f"Calculation failed: {e}")
```

### 4. Visualization Integration Pattern

**Matplotlib Canvas Integration**:
```python
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

class VisualizationTab(TabInterface):
    def init_ui(self):
        # Create matplotlib canvas
        self.figure = Figure(figsize=(8, 6))
        self.canvas = FigureCanvas(self.figure)
        self.layout.addWidget(self.canvas, 0, 0)
        
        # Calculation triggers plot update
        self.calculate_btn.clicked.connect(self.update_plot)
    
    def update_plot(self):
        """Update visualization with new data."""
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        
        # Get data from calculator
        data = self.calculator.get_plot_data()
        ax.plot(data['x'], data['y'])
        ax.set_xlabel('X Label')
        ax.set_ylabel('Y Label')
        
        self.canvas.draw()
```

**Horizontal Layout Pattern with Multiple Visualizers**:
```python
from packages.visualizer.unitcell_visualizer import UnitcellVisualizer

class ComplexVisualizationTab(TabInterface):
    def init_ui(self):
        # Main horizontal layout
        main_layout = QHBoxLayout(self)
        
        # Left column - controls and inputs
        left_column = QWidget()
        left_layout = QVBoxLayout(left_column)
        left_layout.addWidget(input_group)
        left_layout.addWidget(calculate_button)
        left_layout.addWidget(results_group)
        left_layout.addStretch()  # Push content to top
        
        # Right column - visualizations
        right_column = QWidget()
        right_layout = QVBoxLayout(right_column)
        right_layout.addWidget(self.primary_visualizer)
        right_layout.addWidget(self.unitcell_visualizer)
        
        # Add columns with proportional sizing
        main_layout.addWidget(left_column, 1)      # 1 part
        main_layout.addWidget(right_column, 1.5)   # 1.5 parts
    
    def set_parameters(self, params: dict):
        """Initialize visualizers with CIF file if provided."""
        cif_file = params.get('cif_file')
        if cif_file:
            self.unitcell_visualizer.set_parameters({"cif_file": cif_file})
            self.unitcell_visualizer.visualize_unitcell()
```
### 5. Structure Factor UI/Visualization specifics

- The `StructureFactorTab` uses subtabs: "In use" and "Deprecated".
- "In use" subtab layout: 2 rows × 4 columns.
  - (0,0): 3D plot via `StructureFactorVisualizer3D`.
  - (0,1)-(0,3): 2D sliced plots (HK/HL/KL) via `StructureFactorVisualizer2D`.
  - (1,0): energy + initialize controls.
  - (1,1)-(1,3): integer spinbox+slider controls fixing L, K, H respectively.
- The 2D plots show full HKL labels per point and hide the colorbar. Marker size/color scale use an optional `value_max` (typically |F(0,0,0)|).
- The 3D plot supports translucent plane overlays. Controls update the corresponding planes live using `set_plane_values(H=?, K=?, L=?)`.

## Key Architecture Principles

### 1. Separation of Concerns

**Backend Modules**:
- Pure Python calculations
- No PyQt dependencies
- Use Lab class for coordinate systems
- Return data as dictionaries
- Handle scientific computations

**Frontend Tabs**:
- PyQt5 UI components only
- User interaction handling
- Data visualization
- Error message display
- State management

### 2. Parameter Flow Architecture

```
Global Parameters (MainWindow)
    ↓ set_parameters()
Tab Instances
    ↓ initialize()
Backend Calculators
    ↓ Lab.initialize()
Coordinate System Objects
```

### 3. Coordinate System Management

**Always Use Lab Objects**:
```python
# CORRECT: Use Lab for all coordinate work
lab = Lab()
lab.initialize(a, b, c, alpha, beta, gamma, roll, pitch, yaw, theta, phi, chi)
hkl = lab.angles_to_hkl(tth, theta, phi, chi)

# INCORRECT: Manual coordinate calculations
# Don't implement coordinate transforms manually
```

**Frame Documentation Pattern**:
```python
def calculate_vector(self, input_vector):
    """Calculate transformed vector.
    
    Args:
        input_vector (np.array): Vector in lattice frame
        
    Returns:
        np.array: Vector transformed to lab frame
    """
    return self.lab.transform_lattice_to_lab(input_vector)
```

### 4. State Management Logic

**Tab State Pattern**:
```python
def get_state(self):
    """Get current tab state for session saving."""
    return {
        'input_values': self.get_input_values(),
        'results': self.calculator.results,
        'visualization_state': self.get_plot_state()
    }

def set_state(self, state):
    """Restore tab from saved state."""
    self.set_input_values(state.get('input_values', {}))
    if 'results' in state:
        self.display_results(state['results'])
```

## Testing Patterns

### 1. Backend Testing
```python
import unittest
from packages.module_name.interface import ModuleName

class TestModuleName(unittest.TestCase):
    def setUp(self):
        self.calculator = ModuleName()
        self.test_params = {
            'a': 5.0, 'b': 5.0, 'c': 5.0,
            'alpha': 90.0, 'beta': 90.0, 'gamma': 90.0
        }
    
    def test_initialization(self):
        self.calculator.initialize(self.test_params)
        self.assertTrue(self.calculator._initialized)
    
    def test_calculation(self):
        self.calculator.initialize(self.test_params)
        result = self.calculator.calculate_something(test_input)
        self.assertIsNotNone(result)
```

### 2. Coordinate System Testing
```python
def test_coordinate_transformations(self):
    """Test coordinate system transformations."""
    lab = Lab()
    lab.initialize(5.0, 5.0, 5.0, 90.0, 90.0, 90.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    
    # Test known transformations
    lattice_vector = np.array([1, 0, 0])
    lab_vector = lab.transform_lattice_to_lab(lattice_vector)
    
    # Verify transformation correctness
    expected = np.array([1, 0, 0])  # For this specific case
    np.testing.assert_array_almost_equal(lab_vector, expected)
```

## Configuration Management Logic

### 1. Configuration Loading Pattern
```python
import json
import os

def load_config(config_name):
    """Load configuration file safely."""
    config_path = os.path.join('config', f'{config_name}.json')
    try:
        with open(config_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}  # Return default empty config
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in {config_path}: {e}")
```

### 2. Tab Registry Processing
```python
def load_tab_registry(self):
    """Load and validate tab registry."""
    registry = load_config('tab_registry')
    valid_tabs = []
    
    for tab_config in registry.get('tabs', []):
        if self.validate_tab_config(tab_config):
            valid_tabs.append(tab_config)
        else:
            print(f"Invalid tab config: {tab_config}")
    
    return sorted(valid_tabs, key=lambda x: x.get('order', 999))
```

## Development Workflow

### 1. Adding New Functionality
1. **Plan**: Create UML diagram in `uml/` directory
2. **Backend**: Implement in `packages/module_name/interface.py`
3. **Test**: Create tests in `tests/module_name/`
4. **Frontend**: Create tab in `packages/gui/tabs/`
5. **Register**: Add to [tab_registry.json](mdc:config/tab_registry.json)
6. **Document**: Update relevant documentation

### 2. Debugging Strategy
1. **Check Initialization**: Verify parameters passed correctly
2. **Coordinate Systems**: Ensure Lab object properly initialized
3. **UI Updates**: Verify backend results reach frontend
4. **Error Propagation**: Check error handling at each layer

### 3. Performance Considerations
- **Lazy Loading**: Only initialize calculators when needed
- **Caching**: Store expensive calculations in calculator state
- **Visualization**: Update plots only when data changes
- **Memory**: Clear large datasets when switching tabs

## Integration Points

### 1. Main Window Integration
- **Parameter Distribution**: `set_parameters()` called on all tabs
- **Tab Management**: Dynamic loading from registry
- **State Persistence**: Session save/restore functionality

### 2. Visualization Integration
- **Matplotlib Backend**: Use Qt5Agg backend consistently
- **Figure Management**: One figure per tab, clear before redraw
- **Interactive Elements**: Connect matplotlib events to Qt signals

### 3. File I/O Integration
- **CIF Files**: Use CifFile library for crystal structure import
- **Session Files**: JSON format for state persistence
- **Export**: Support multiple format exports (PNG, PDF, CSV)

This project logic provides the foundational patterns for extending and maintaining the RIXS Preparation Toolbox while ensuring consistency across all modules and maintaining the clean separation between backend calculations and frontend presentation.